#!/usr/bin/env node
// Load first dependencies
const {Command} = require('commander');
const {exec} = require('child_process');
const path = require('path');
const program = new Command();
const {existsSync, mkdirSync, readFileSync, promises} = require('fs');

// Disable https://nextjs.org/telemetry
process.env['NEXT_TELEMETRY_DISABLED'] = '1';

// TODO: Enabled this option for backward-compatibility support, but remove later to support newer syntax
program.storeOptionsAsProperties();

program.version(`
    0.0 alpha
`); // todo

program.description(`
    Point Network
    https://pointnetwork.io/

    Licensed under MIT license.
`);

// Print disclaimer
require('./resources/disclaimer').output();

// NOTE: After changing parameters here, update the documentation
program
    .command('go', {isDefault: true})
    .description('start the node')
    .action(() => {program.go = true;});
program.option('--datadir <path>', 'path to the data directory');
program.option('-v, --verbose', 'force the logger to show debug level messages', false);
program
    .command('attach')
    .description('attach to the running point process')
    .action(() => (program.attach = true));
program
    .command('makemigration')
    .description('[dev mode] auto create db migrations from models')
    .action(() => (program.makemigration = true));
program
    .command('migrate')
    .description('[dev mode] run migrations')
    .action(() => (program.migrate = true));
program
    .command('compile')
    .description('compile contracts')
    .action(() => (program.compile = true));
program
    .command('migrate:undo')
    .description('[dev mode] undo migration')
    .action(() => (program.migrate = program.migrate_undo = true));
program
    .command('demo')
    .description('dump demo configs to ~/.point')
    .action(() => (program.demo = true));
program
    .command('debug-destroy-everything')
    .description('destroys everything in datadir: database and files. dangerous!')
    .action(() => (program.debug_destroy_everything = true));
program
    .command('deploy <path>')
    .description('deploy a website')
    .action((path, cmd) => {
        program.deploy = path;
        program.deploy_contracts = Boolean(cmd.contracts);
        program.dev = Boolean(cmd.dev);
    })
    .option('--contracts', '(re)deploy contracts too', false)
    .option('--dev', 'deploy zapp to dev too', false);

program
    .command('migrate-contract <site>')
    .description('migrates contracts genesis data')
    .action(cmd => {
        program.migrateContract = true;
        program.site = cmd;
    });
// program.option('--shutdown', 'sends the shutdown signal to the daemon'); // todo
// program.option('--daemon', 'sends the daemon to the background'); // todo
// program.option('--rpc <method> [params]', 'send a command to the daemon'); // todo
program.parse(process.argv);

const ctx = {};

if (program.datadir) {
    process.env.DATADIR = program.datadir;
}

function getContractAddress(name) {
    const filename = path.resolve(__dirname, 'truffle', 'build', 'contracts', `${name}.json`);

    if (!existsSync(filename)) {
        return;
    }

    const {networks} = require(filename);

    for (const network in networks) {
        const {address} = networks[network];
        if (address && typeof address === 'string') {
            return address;
        }
    }
}

// ------------------ Patch Config ------------ //

if (process.env.MODE === 'e2e') {
    process.env.IDENTITY_CONTRACT_ADDRESS = getContractAddress('Identity');
    process.env.STORAGE_PROVIDER_REGISTRY_CONTRACT_ADDRESS = getContractAddress('StorageProviderRegistry');
}

const config = require('config');
const logger = require('./core/log');
const Model = require('./db/model');
const Deployer = require('./client/zweb/deployer');
const DB = require('./db');

ctx.basepath = __dirname;

// --------------- Dump Demo Configs ----------------- //
// Must be placed before we're checking for existence of any configs!
if (program.demo) {
    require('./resources/demo');
    return;
}

// ------------------- Init Logger ----------------- //

ctx.log = logger.child({module: 'point'}); // TODO: account
const log = ctx.log.child({module: 'point'});

ctx.exit = code => (log.close(), process.exit(code));
ctx.die = err => (log.fatal(err), ctx.exit(1));

// ----------------- Console Mode -------------------- //

if (program.attach) {
    const Console = require('./console');
    const console = new Console(ctx);
    console.start();
    return;
}

// -------------------- Solidity Migrations --------------------- //

if (program.migrateContract) {
    if (program.site.length === 0) return ctx.die('error: missing site');
    const Deploy = require('./core/deploy');
    const deploy = new Deploy(ctx);
    deploy.migrate(program.site);
    return;
}

// -------------------- Deployer --------------------- //

if (program.deploy) {
    if (program.deploy.length === 0) return ctx.die('error: missing path');
    const Deploy = require('./core/deploy');
    const deploy = new Deploy(ctx);
    deploy.deploy(program.deploy, program.deploy_contracts, program.dev).then(ctx.exit);
    return;
}

// ---------------- Migration Modes ---------------- //

if (program.makemigration) {
    // A little hack: prepare sequelize-auto-migrations for reading from the current datadir config
    process.argv = [
        './point',
        'makemigration',
        '--models-path',
        './db/models',
        '--migrations-path',
        './db/migrations',
        '--name',
        'automigration'
    ];
    const SequelizeFactory = require('./db/models');
    SequelizeFactory.init(ctx);

    require('./node_modules/sequelize-auto-migrations/bin/makemigration.js');
    return;
}
if (program.migrate) {
    const seq_cmd = program.migrate_undo ? 'db:migrate:undo' : 'db:migrate';
    exec(
        `npx sequelize-cli ${seq_cmd} --url sqlite:${
            path.join(config.get('datadir'), config.get('db.storage'))} --env ${config.get('db.env')}`,
        (error, stdout, stderr) => {
            if (error) {
                return log.error(error, 'Migration error');
            }
            if (stderr) {
                return log.error(`Migration stderr: ${stderr}`);
            }
            log.debug(`Migration result: ${stdout}`);
        }
    );
    return;
}

// ------------------ Remove Everything ------------ //

if (program.debug_destroy_everything) {
    // todo: remove in prod, dangerous
    ctx.db = new DB(ctx);
    DB.__debugClearCompletely(ctx); // async!
    return;
}

// ------------------ Compile Contracts ------------ //

const CONTRACT_ADDRESSES = ['Identity', 'Migrations', 'StorageProviderRegistry'];

if (program.compile) {
    const getImports = dependency => {
        const dependencyNodeModulesPath = path.join(__dirname, 'node_modules/', dependency);
        if (!existsSync(dependencyNodeModulesPath)) {
            throw new Error(
                `Could not find contract dependency "${dependency}", have you tried npm install?`
            );
        }
        return {contents: readFileSync(dependencyNodeModulesPath, 'utf8')};
    };

    log.info('Compiling contracts...');

    const buildDirPath = path.resolve(__dirname, 'truffle', 'build', 'contracts');
    if (!existsSync(buildDirPath)) {
        mkdirSync(buildDirPath);
    }
    const contractsPath = path.resolve(__dirname, 'truffle', 'contracts');

    Promise.all(CONTRACT_ADDRESSES.map(async name => {
        const sourceFileName = `${name}.sol`;
        const buildPath = path.join(buildDirPath, `${name}.json`);
        const filepath = path.join(contractsPath, sourceFileName);
        if (existsSync(buildPath)) {
            log.debug(`Contract build ${name}.json already exists, skipping`);
            return;
        }
        const content = await promises.readFile(filepath, 'utf8');
        const version = await Deployer.getPragmaVersion(content);
        const solc = require(`solc${version.split('.').slice(0, 2).join('_')}`);
        const compilerProps = {
            language: 'Solidity',
            sources: {[sourceFileName]: {content}},
            settings: {outputSelection: {'*': {'*': ['*']}}}
        };
        const artefact = solc.compile(JSON.stringify(compilerProps), {import: getImports});

        if (artefact) {
            await promises.writeFile(
                path.join(buildPath),
                JSON.stringify(JSON.parse(artefact).contracts[sourceFileName][name]),
                'utf-8'
            );
            log.debug(`Contract ${sourceFileName} successfully compiled`);
        } else {
            throw new Error('Compiled contract is empty');
        }
    }))
        .then(() => {
            log.info('Contracts successfully compiled');
            process.exit(0);
        })
        .catch(e => {
            log.error(e, 'Failed to compile contracts');
            process.exit(1);
        });
    return;
}

// ------------ Main Cycle After This Block ---------- //

if (!program.go || program.args.length > 0) {
    program.help();
    ctx.die();
}

// ------------------ Gracefully exit ---------------- //

let exiting = false;
async function _exit(sig) {
    if (exiting) return;
    exiting = true;

    const errors = [];

    log.info('Received signal ' + sig + ', shutting down...');

    try {
        if (ctx.db && ctx.db.shutdown) await ctx.db.shutdown();
    } catch (e) {
        errors.push('Error while shutting down database: ' + e);
    }

    if (errors.length) {
        for (const e of errors) {
            log.error(e);
        }
    } else {
        log.info('Successfully shut down.');
    }

    process.exit(1);

    // todo: shut down everything else
}

const sigs = [
    'exit',
    'SIGHUP',
    'SIGINT',
    'SIGQUIT',
    'SIGILL',
    'SIGTRAP',
    'SIGABRT',
    'SIGBUS',
    'SIGFPE',
    'SIGUSR1',
    'SIGSEGV',
    'SIGUSR2',
    'SIGTERM'
];
sigs.forEach(function (sig) {
    process.on(sig, function () {
        _exit(sig);
    });
});

process.on('uncaughtException', err => {
    ctx.log.error({message: err.message, stack: err.stack}, 'Error: uncaught exception');
});

process.on('unhandledRejection', (err, second) => {
    ctx.log.debug(err, second);
    ctx.log.error({message: err.message, stack: err.stack}, 'Error: unhandled rejection');
});

Model.setCtx(ctx);

// ------------------- Start Point ------------------- //

const Point = require('./core');
const point = new Point(ctx);
point.start();
